NOTE: add the first part to client.py and call it after sending the ballot to server; add the second part to server.py so it can verify the signature after receiving the balloe
---------------------------------------------------------------------------------------------------------------
from Crypto.PublicKey import RSA

# RSA SIGNING - add to client.py - for each voter sending their vote, a public/private keypair will be generated. However, in a real application, this would be generated by a trusted third-party entity

def sign_vote (username, vote_data): # pass in voter's username as well as their vote data represented as bytes

	key_set = keyPair = RSA.generate(bits=1024)
	n, e, d = hex(key_set.n), hex(key_set.e), hex(key_set.d) # public_key = {n,e}, private_key = {n, d}

	# wite public and private keys to a file called {voter's username}.txt so that server can verify -- in this order, store n, e, d for each line
	with open(username+".txt", "w") as f:
		f.write(n)
		f.write(e)
		f.write(d)
		f.close()
	
	hash = sha256(vote_data).digest() # hash message then sign; NOTE: our ballot is already encrypted by using CBC from hash of voter data, so this is extra secure
	signature = pow(hash, d, n) --> take hash^d (mod n)
	
	# TODO send the signature to the server via socket here

--------------------------------------------------------------------------------------------------------------

from Crypto.PublicKey import RSA
# RSA VERIFICATION - add to server.py - for each voter sending their vote, a public/private keypair will be generated. However, in a real application, this would be generated by a trusted third-party entity

def verify_signature (signature, username, vote_data):
	# server opens the RSA keypair file corresponding to username
	try:
		with open(username+".txt", "r") as f: 
			n = f.readline()
			e = f.readline()
			d = f.readline()
			f.close() 
	except IOError:
		# if filename does not exist, return False - server should close connection
		return False

	# create hash from vote data (should be bytes)
	hash = sha256(vote_data).digest()
	created_signature = pow(signature, e, n) # take signature^e mod n to verify
	return hash == created_signature
